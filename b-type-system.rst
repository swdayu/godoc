
Go语言类型系统

.. title:: Go语言类型系统

* `基本分类`_
* `命名类型`_
* `定义类型`_
* `底层类型`_
* `核心类型`_
* `相同类型`_
* `赋值操作`_
* `操作数的类型`_
* `整数值的表示`_
* `浮点值的表示`_
* `常量的类型`_
* `常量表达式`_
* `类型转换`_
* `可比类型`_
* `静态类型`_
* `接口类型`_
* `类型约束`_
* `类型参数`_

基本分类
=========

总体上，Go语言的类型可分为预声明类型、复合类型、在预声明类型和复合类型基础上构建的其他类型。

预声明类型::

    布尔类型：bool
    整数类型：int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr (byte rune)
    浮点类型：float32 float64
    复数类型：complex64 complex128
    字符串类型：string

    其中int uint uintptr的长度取决于特定平台，可能是32位或者64位
    另外还预声明了两个整数类型的别名：字节类型byte是uint8的别名，字符类型rune是int32的别名
    以上除了byte和rune，都是定义的类型（defined type），是独立的相互区分的

复合类型（由以下类型字面量表示）::

    结构体类型：struct { a T }
    接口类型：interface { M(a T) R }
    函数类型：func (a T) R，func (p *Point, a T) R
    数组类型：[N]T
    切片类型：[]T
    映射类型：map[K]T
    通道类型：chan<- T，<-chan T，chan T
    指针类型：*T

其他类型可以通过以下方式创建：

- 类型声明（包括使用别名声明的类型别名、使用类型定义声明的新类型）
- 类型参数声明（在类型或函数声明中声明的类型参数）
- 类型字面量可以用在类型声明中创建别名或新类型，或通过new、make、初始化直接创建复合类型值

使用类型声明创建别名::

    type AliasBasic = int
    type AliasArray = [4]int
    type AliasStruct = struct {a,b int}
    type AliasInterface = interface { Read() int }
    type AliasFunc = func (a,b int) int

    type AliasPbasic = *int
    type AliasParray = *[4]int
    type AliasPstruct = *struct{a,b int}
    type AliasPinterface = *interface{Read() int}
    type AliasPfunc = *func(a,b int) int
    type AliasPslice = *[]int
    type AliasPmap = *map[string]int
    type AliasPchan = *chan<- int

使用类型声明创建新类型::

    type BasicType int
    type ArrayType [4]int
    type StructType struct {a,b int}
    type InterfaceType interface { Read() int }
    type FuncType func (a,b int) int

    type Pbasic *int
    type Parray *[4]int
    type Pstruct *struct{a,b int}
    type Pinterface *interface{Read() int}
    type Pfunc *func(a,b int) int
    type Pslice *[]int
    type Pmap *map[string]int
    type Pchan *chan<- int

在类型声明中创建的类型参数::

    type Type[P any, C comparable] struct {a,b P; c C}

    type BasicType[P any] Type[P, int]
    type ArrayType[P any] [4]P
    type StructType[P any] struct {a,b P}
    type InterfaceType[P any] interface { Read() P }
    type FuncType[P any] func (a,b P) int

    // 不能用类型别名形式创建泛型类，以下声明是非法的
    type AliasBasic[P any] = Type[P, int]
    type AliasArray[P any] = [4]P
    type AliasStruct[P any] = struct {a,b P}
    type AliasInterface[P any] = interface { Read() P }
    type AliasFunc[P any] = func (a,b P) int

在函数声明中创建的类型参数::

    func min[T ~int|~float64](x, y T) T {
        if x < y {
            return x
        }
        return y
    }

使用类型字面量直接创建复合类型值::

    func calc(a,b int) int {
        return a + b
    }

    a := [4]int{1, 2, 3, 4}
    b := struct{a,b int}{1, 2}
    c := interface{Read() int}(nil)
    d := (func (a,b int) int)(calc)

    pslice := new([]int)
    pchan := new(chan int)
    slice := make([]int, 2)
    achan := make(chan int, 3)

命名类型
========

命名类型（named type）包括：

1. 预声明类型，例如 ``bool int uint byte rune float64 complex128 string``
2. 使用类型定义声明的新类型 ``type NewType ExistType; type NewType TypeLit``
3. 在类型或函数声明中声明的类型参数 ``type TypeName 或者 func FuncName [P TypeConstraint, ...] …``
4. 命名类型的别名 ``type AliasType = NamedType``

未命名类型是使用类型字面量（TypeLit）表示的类型：

1. 结构体类型，例如 ``struct { a,b int }``
2. 接口类型，例如 ``interface { Write(data *byte) int }``
3. 函数类型，例如 ``func (a,b int) int``
4. 数组类型，例如 ``[4]T``
5. 切片类型，例如 ``[]T``
6. 映射类型，例如 ``map[K]T``
7. 通道类型，例如 ``chan<- int``
8. 指针类型，例如 ``*T *int *Point *struct{a int} *func()int *[4]T *chan<-int``
9. 未命名类型的别名 ``type AliasType = TypeLit``

定义类型
========

定义的类型（defined type）包括：

1. 预声明类型中的定义类型，除了byte和rune外的其他所有预声明类型
2. 使用类型定义声明的新类型，例如 type NewType OriginType
3. 使用类型定义创建的泛型类也是定义类型，例如 type NewType[P TypeConstraint, ...] …

使用别名声明的类型别名，只是一个别名，不是定义的新类型。定义类型是一个新的，独立的、
与其他类型都不同的类型，它与创建它的原类型（OriginType）也不同，但是它与原类型有相同
的底层类型（underlying type）。定义类型与对应的底层类型之间不会自动隐式进行类型转换，
必须显式转换。

定义类型有自己的名称，以及自己的可能为空的成员函数集。一个定义类型可以创建自己的
成员函数，除非原类型是接口或者复合类型，否则定义类型不会获得原类型的成员函数。 ::

    type Mutex struct { ... }
    func (m *Mutex) Lock()
    func (m *Mutex) Unlock()
    type NewMutex Mutex // NewMutex与Mutx有相同的成员变量，它在后面可以定义自己的成员函数，但现在它的成员函数集合为空

原类型是接口，新类型会获得接口定义的成员函数集合::

    type Block interface {
        BlockSize() int
        Encrypt(src,dst []byte)
        Decrypt(src,dst []byte)
    }
    type MyBlock Block // Block是接口，MyBlock与Block有相同的成员函数集合

原类型是复合类型，新类型获得复合类型的相关操作::

    type NewMutex struct { // 原类型是复合类型，NewMutex与结构体有相同的成员变量，类型*NewMutex也包含了Mutex的成员函数集合
        Mutex
    }
    type IntArray [5]int // 原类型是复合类型，IntArray获得了数组对元素的相关操作

利用新类型能创建自己的成员函数，可以为布尔、数值、字符串类型创建特别的操作::

    type TimeZone int
    const (
        EST TimeZone = -(5 + iota)
        CST
        MST
        PST
    )
    func (tz TimeZone) String() string {
        return fmt.Sprintf("GMT%+dh", tz)
    }

底层类型
========

每个类型T都有自己的底层类型（underlying type）：

1. 如果T是预声明类型或者类型字面量，那么T的底层类型是它自己
2. 否则T的底层类型是类型声明中原类型的底层类型
3. 如果T是类型参数，它的底层类型是对应类型约束的底层类型（一个接口类型）

例如::

    type (
        A1 = string
        A2 = A1 // sting、A1、A2的底层类型都是string
    )
    type (
        B1 string
        B2 B1    // string B1 B2的底层类型是string
        B3 []B1
        B4 B3   // []B1 B3 B4的底层类型是[]B1
    )
    func f[P any](x P) // P的底层类型是interface{}

核心类型
========

如果类型T是非接口类型，那么T的核心类型（core type）是它的底层类型。

如果T是接口类型，只有满足以下条件之一才有核心类型：

1. 存在单个类型U，是接口类型T定义的所有类型的底层类型，那么T的核心类型是U
2. T定义的类型只包含通道类型chan E，那么T的核心类型是chan E
3. T定义的类型只包含通道类型chan<- E和chan E，那么T的核心类型是chan<- E
4. T定义的类型只包含通道类型<-chan E和chan E，那么T的核心类型是<-chan E

另外为了方便切片操作，如果T的核心类型是[]byte或者string，那么称T的核心类型
是bytestring。bytestring并不是一个真正的类型，它仅仅为了描述对字节序列的
操作而存在，这种字节序列可以是字节切片或者字符串。

因此，核心类型定义的是Go语言中最基本的静态类型，它不包括使用类型定义语句创建
的新类型，也不包括接口类型和类型参数。

相同类型
========

两个类型要么相同（identical），要么不同（different）。一个命名类型（named type）
总是与任何其他类型不同（除非是命名类型的别名）。用相同的类型约束声明的两个类型参数
同理也是不同的。

因此一个命名类型只会与自己、或者自己的类型别名相同，它与任何其他类型都不同。非命名
类型要相同，它们的底层类型字面结构以及元素或成员的类型必须相同：

1. 两个数组类型是相同的，如果有相同的元素类型和相同的数组长度
2. 两个切片类型是相同的，如果有相同的元素类型
3. 两个结构体类型是相同的，如果成员有相同的顺序、名字、类型、标记，不同包中未导出的成员永远不同
4. 两个指针类型是相同的，如果指向的类型相同
5. 两个函数类型是相同的，如果有相同数量的参数和返回值，并且对应的参数和返回值类型相同
6. 两个接口类型是相同的，如果它们定义的类型集合相同
7. 两个映射类型是相同的，如果键类型和值类型都相同
8. 两个通道类型是相同的，如果元素类型相同并有相同的方向
9. 两个实例化类型是相同的，如果对应的类型相同，并且类型实参都相同

例如::

    type (
        A0 = []string
        A1 = A0                    // 类型[]string、A0、A1相同
        A2 = struct{a,b int}       // 类型struct{a,b int}、A2相同
        A3 = int                   // 类型int、A3相同
        A4 = func(A3, float64) *A0 // 类型func(int,float64)*[]string、A4、A5相同
        A5 = func(x int, _ float64) *[]string
        B0 A0                      // 类型B0与A0与A1都不同
        C0 = B0                    // 类型C0与B0相同
        B1 []string                // 类型B1与B0与[]string都不同
        B2 struct{a,b int}         // 类型B2与B3与struct{a,b int}都不同
        B3 struct{a,c int}
        B4 func(int, float64) *B0  // 类型B4与B5不同，B0与A1不同，因此两个底层函数类型也不同
        B5 func(x int, y float64) *A1
        D0[P1,P2 any] struct{x P1; y P2} // 类型参数P1与P2不同，因为是两个命名类型
        E0 = D0[int,string] // 类型E0与D0[int,string]相同，D0[int,string]与struct{x int; y string}不同
    )

赋值操作
========

如果满足以下条件之一，类型V的变量x可以赋值给类型T的变量：

1. 类型V和T是相同类型
2. V和T都不是类型参数，有相同的底层类型，并且V和T至少一个是未命名类型
3. V和T是有相同元素类型的通道类型，V是双向通道，并且V和T至少一个是未命名类型
4. T是一个非类型参数的接口类型，并且x实现了T
5. T是一个非类型参数的指针、函数、切片、映射、通道、接口类型，x是预声明的值nil
6. x是一个无类型的可以用类型T的值表示的常量

如果V或者T是类型参数，需要满足以下条件之一才可赋值：

1. x是预声明的值nil，T是一个类型参数，x可以赋值给T类型集合中的每个类型
2. V是一个未命名类型，T是一个类型参数，x可以赋值给T类型集合中的每个类型
3. V是一个类型参数，T是一个未命名类型，V类型集合中的每个类型的值都可以赋值给T

底层类型相同的类型赋值的例子::

    type AliasInt = int
    type MyInt int

    a := 1 // a的类型是int
    b := AliasInt(2)
    c := MyInt(3)

    b = a        // 合法，因为AliasInt和int是相同的类型
    c = a        // 非法，虽然MyInt和int的底层类型相同，但必须要有一个非命名类型才能赋值
    c = MyInt(a) // 合法，必须使用类型转换

    type AliasArray = [3]int // AliasArray与[3]int是相同的类型
    type MyArray [3]int      // MyArray与[3]int是两个不同的类型
    type UrArray [3]int      // UrArray与MyArray与[3]int都不同

    var d AliasArray = [3]int{1, 2, 3}
    var e MyArray = [3]int{4, 5, 6}
    var f UrArray = [3]int{7, 8, 9}

    e = d          // 合法，MyArray与AliasArray有相同的底层类型，且AliasArray是一个非命名类型
    e = f          // 非法，虽然底层类型相同，但必须要有一个非命名类型才能赋值
    e = MyArray(f) // 合法，必须使用类型转换

赋值语句将变量存储的值替换为一个新的用表达式表示的值，一个赋值语句可以给一个
或多个变量赋值::

    Assignment = ExpressionList assign_op ExpressionList .
    assign_op = [ add_op | mul_op ] "=" .
    add_op = "+" | "-" | "|" | "^" .
    mul_op = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

赋值语句分为简单赋值（"="）和算术赋值（op=）。左操作数必须是可取地址的，或者
是映射的索引表达式，或者是空标识符（仅简单赋值允许）。算术赋值只能有单个的左
操作数和右操作数，并且左操作数不能是空标识符。

简单赋值可以将多个值赋给对应的相同数量的多个变量，有两种形式。第一种是右操作数
是单个有多个返回值的函数调用、或者一个通道映射操作、或者一个类型断言，左操作数
的个数必须与右边值得个数相等。第二种形式，右边每个表达式都只产生单个值，并且第
n个表达式可以给左边的第n个变量对应的类型赋值。空标识符可以用来忽略右边的值。

赋值语句在求值时，左边的索引表达式、指针解引用（包括成员选择时的隐式指针解引用）、
以及右边的表达式，会按通用求值规则先进行求值。即所有的函数调用、成员函数调用、
通道接收操作、二元逻辑运算都按照词法从左到右的顺序求值。

赋值语句中，右边的每个值都必须可以赋值给左边的类型，但是有以下特殊情况：

1. 任何有类型的值都可以赋值给空标识符
2. 无类型的常量赋值给接口变量或空标识符，常量首先会隐式转换为它的默认类型
3. 无类型的布尔值赋值给接口变量或空标识符，该值首先会隐式的转换为bool类型

变量声明语句创建一个或多个变量，并绑定到对应的标识符，并为每个变量给定类型和初
始值。 ::

    VarDecl = "var" (VarSpec | "(" {VarSpec ";"} ")" ) .
    VarSpec = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
    ShortVarDecl = IdentifierList ":=" ExpressionList

如果给定了表达式列表，它使用赋值语句规则对变量进行初始化，否则变量的值初始化为
零值。如果给定了类型，每个变量的类型被设定为对应的类型，否则变量的类型根据赋值
中初始值的类型决定。如果初始值是无类型的常量和值，它们会被隐式的转换成对应的默认
类型。预声明的值nil不能用来初始化一个没有显式指定类型的变量。

短变量声明形式左边的变量可以是已经声明的，相当于对这个变量重新赋值，而不是创建
这个变量，但是左边的变量至少要有一个非空变量是需要创建的。短声明形式仅能出现在
函数内部。

操作数的类型
============

比较操作的两个操作数的类型必须能相互赋值，除非涉及移位操作或者无类型常量，否则
对于其他二元操作（包括逻辑操作和算术操作），操作数的类型必须是相同的类型。 ::

    binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
    rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
    add_op     = "+" | "-" | "|" | "^" .
    mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

逻辑操作（&&、||、!）用于布尔值并产生相同类型的结果，逻辑操作首先会对第一个操作
数进行求值，然后按需要对第二个操作数进行求值::

    &&  AND     p && q 相当于 如果p则q否则false
    ||  OR      p || q 相当于 如果p则true否则q
    !   NOT     !p     相当于 如果p则false否则true

除了移位操作，如果一个操作数是一个无类型常量另一个操作数不是，那么常量会隐式的转
换成另一个操作数的类型。移位操作的右操作数必须是一个整型，或者是一个无类型常量其
值可以用uint表示。如果移位操作的左操作数是一个无类型常量而右操作数不是，这个常量
会被隐式的转换成当这个常量替换整个移位操作后应该的类型。

算术操作除了加减乘除可以用于整数、浮点、复数类型外，其他都只能用在整数类型上::

    +                    整型、浮点、复数、字符串
    -                    整型、浮点、复数
    *                    整型、浮点、复数
    /                    整型、浮点、复数
    %                    整型
    &  AND               整型（与）
    |  OR                整型（或）
    ^  XOR               整型（异或）
    &^ bit clear (NAND)  整型（与非）
    <<                   整型 integer << interger 右操作数>=0
    >>                   整型 integer >> interger 右操作数>=0

如果操作数的类型是一个类型参数，操作符必须可以应用到类型参数定义的所有类型上。

整数值的表示
============

整数的除法q=x/y与取余r=x%y的关系是::

    x=q*y+r 并且 |r|<|y|
    一个例外是，如果x是对应整数的最小负数，由于二进制补码上溢q=x/-1的值是x余数是0

除法和取余中的除数不能是0，位移操作的右操作数必须大于等于0，否则常量会编译报错变量
会导致运行时异常。整数的计算会自然上溢，不会产生运行时异常，编译器不能依赖不会发生
溢出来优化代码，例如不能假定 ``x<x+1`` 总会成立。

但是，一个整数常量必须能用对应的整数类型精确表示，如果不能表示或者溢出，将会报错。
常量的值如果可以用对应的整数类型表示，即使类型不同也没问题，例如在整数范围内的小数
部分为零的一个浮点常量可以用对应的整数常量表示。小数部分不是零的浮点常量不能转换成
整数常量，而整数常量可以转换成浮点常量。

对于非常量值，当使用强制类型转换时，整数和浮点可以相互转换。整数类型之间进行转换时，
如果值是有符号的，符号位会被隐式的扩展到无限精度，然后被截取适合结果类型的大小。整型
之间的转换总是产生一个合法的值，不会提示有溢出。如果将一个浮点转换成整数，小数部分被
丢弃（向0截断）。

浮点值的表示
============

浮点或复数除以0的结果并没有在IEEE-754标准中定义，是否抛出运行时异常由特定实现决定。
特定实现可以合并多个浮点操作到单个融合操作（single fused operation），可能跨越代码
语句，其结果可能与单独执行并近似每个操作的值不一样。显式的浮点类型转换会将值近似到目
标类型的精度，可以用来阻止融合操作。例如一些平台提供了FMA（fused multiply and add）
指令用来直接计算x*y+z的结果，避免x*y中间计算过程中的精度损失。下面这些例子展示Go的
实现如果使用了这个指令的情况::

    r = x*y + z // 以下这些计算都可以使用FMA计算r
    r = z; r += x*y
    t = x*y; r = t + z
    *p = x*6; r = *p + z
    r = x*6 + float64(z) // 这些计算不能使用FMA，因为有显式的精度转换
    r = float64(x*6) + z
    r = z; r += float64(x*y)
    t = float64(x*6); r = t + z

浮点常量必须能够用对应的浮点类型表示，即常量值可以近似到对应类型的精度而不上溢，如果
发生上溢，将会报错。

当将非常量整数或浮点转换成浮点类型，或者将非常量复数转换成另一个复数类型时，结果值会
近似到目标类型的精度。例如x+0.1可能使用了高于32位的精度，但是float32(x+0.1)则一定
是32位精度。所有涉及非常量浮点或复数的类型转换，如果值不能用对应的目标类型表示，类型
转换是成功的，但转换后的值由实现决定。

常量的类型
==========

常量包括布尔常量、字符常量、整型常量、浮点常量、复数常量、字符串常量。其中字符、
整型、浮点、复数常量称为数值常量。因此常量可以分为布尔常量、数值常量、和字符串
常量。

常量可以是有类型的（typed）和无类型的（untyped），无类型常量有对应的默认类型
（default type）：bool、rune、int、float64、complex128、string。

无类型常量是未明确指定类型的常量，无类型常量包括：

1. 字面常量（整数、浮点、虚数、字符、字符串字面量）
2. 布尔常量ture和false
3. 预声明标识符iota表示的整型常量
4. 只包含无类型操作数的常量表达式

一个常量值可以是：

1. 上面列出的无类型常量
2. 引用常量值的标识符
3. 一个常量表达式
4. 结果是常量值的类型转换
5. 一些内置函数的常量参数调用比如min和max
6. unsafe.Sizeof、cap、len等结果是常量值情况的函数调用
7. real和imag对复数常量的调用，以及complex对数值常量的调用

一个常量可以通过常量声明或者转换显式的指定类型，或者在变量声明、赋值语句、作为
表达式操作数中使用时隐式的给定类型。如果当常量不能用对应类型的值表示时，会出现
错误。如果类型是一个类型参数，常量会被转换成对应类型参数实例化类型的非常量值。

尽管数值常量有任意精度，但编译器可能使用整数进行表示，只有有限精度。为了规范每个
实现都必须：

1. 至少用256位表示一个整型常量
2. 至少用256位表示一个浮点数的尾数，至少用16位表示有符号的指数部分
3. 如果不能精确表示一个整型常量要报错
4. 如果因为上溢而不能表示浮点或复数常量要报错
5. 如果由于精度限制不能表示一个浮点或复数要近似到最近的表示

字面常量和常量表达式产生的结果都需要遵循上面的需求。

如果T不是类型参数，只要满足以下条件之一，常量x可以用类型T的值表示：

1. x是类型T定义的值中的一个
2. T是浮点类型，x可以近似到T类型的精度而不上溢，浮点近似使用IEEE 754的round-to-even规则除了
   IEEE的负零被转成无符号零，注意不能用常量表示一个IEEE负零、NaN、无穷
3. T是一个复数，并且real(x)和imag(x)都可以用T的内部类型（float32或者float64）的值表示

如果T是类型参数，需要x可以用T定义的每个类型的值表示。

常量声明将一个或多个常量标识符绑定到一个常量表达式表示的常量值上。赋值左边的
标识符个数必须与右边的常量表达式值的个数相同。 ::

    ConstDecl = "const" (ConstSpec | "(" { ConstSpec ";" } ")" ) .
    ConstSpec = IdentifierList [[Type] "=" ExpressionList ] .
    IdentifierList = identifier { "," identifier } .
    ExpressionList = Expression { "," Expression } .

如果指定了类型，声明语句中的常量的类型就被指定了，并且右边常量表达式的值必须
可以赋值给这个类型，指定的类型不能是一个类型参数。如果没有指定类型，那么常量
的类型自动与右边的表达式的类型关联，如果右边常量表达式值的类型是一个无类型
（untyped）的常量那么声明的常量也是无类型的。例如表达式是一个浮点字面量，
那么常量标识符也表示一个浮点常量，即使这个浮点常量的小数部分为零。

常量表达式
==========

常量表达式只能包含常量操作数并且可以在编译时求值，无类型的布尔、数值、字符串常
量分别可以合法的作为需要布尔、数值、字符串类型的操作数使用。

一个常量比较操作总是产生一个无类型的布尔常量。如果常量位移的左操作数是一个无类型
的常量，其结果是一个整型常量，否则其结果的类型是左操作数的类型且必须是一个整型。

无类型常量的其他操作的结果都是一个相同类型的无类型常量，即一个布尔、整型、浮点、
复数、或字符串常量。如果除位移操作之外的二元操作的两个操作数是两个不同的无类型，
那么表达式的结果类型按照谁表达能力大就是哪个类型，也即整型、字符类型、浮点、复
数的顺序。例如，一个无类型的整型除以一个无类型的复数的结果是一个无类型的复数常
量。可以调用内置函数complex将无类型的整型、字符类型、浮点常量转换成无类型的复
数常量。

当指定类型时，如果常量不能用目标类型表示会报错，也即指定类型的常量必须能用目标
类型精确表示。常量表达式总是精确的求值，其中间结果和常量自身可能需要用比语言预
定义类型大得多的精度表示。另外除法和取余的第二个操作数不能为零。 ::

    const Huge = 1 << 100  // Huge的值为1267650600228229401496703205376 无类型整数常量
    const Four int8 = Huge >> 98  // Four一个类型为int8的值为4的常量
    uint(-1)     // 非法，-1不能用uint表示
    int(3.14)    // 非法，3.14不能用int表示
    int64(Huge)  // 非法，1267650600228229401496703205376不能用int64表示
    Four * 300   // 非法，300不能用int8表示
    Four * 100   // 非法，400不能用int8表示
    3.14 / 0.0   // 非法，不能除零

对于取反操作，要注意有符号值的取反，取反操作符^在C语言中对应的操作符是~。 ::

    ^1           // 1是无类型的有符号整数，^1是值为-2的无类型的有符号整数
                 // [000]...01 -> [111]...10 -> [111]...01 -> [100]...10 -> -2
    uint8(^1)    // 非法，-2不能用uint8表示
    ^uint8(1)    // 类型为uint8的常量，值为0xFE，00000001->11111110->0xFE
    int8(^1)     // 类型为int8的常量，值为-2
    ^int8(1)     // 类型为int8的常量，值为-2

对于无类型的浮点和复数常量表达式，编译器可能进行精度近似，见前面章节常量部分的
实现限制。这种精度近似可能导致一个浮点常量表达式在需要整型的上下文中是非法的，
尽管如果按照无限精度求值它就是一个整数。

类型转换
========

转换表达式的类型到指定的类型，转换可以是显式的转换，也可能是隐式的在表达式上下文
中发生。显式的转换是 ``T(x)`` 的形式将表达式x的类型转换成类型T::

    Conversion = Type "(" Expression [ "," ] ")" .

如果类型以操作符*或者<-开始，或者类型是以关键字func开始并且没有返回值列表，必须
使用括号避免混淆::

    *Point(p)           // 相当于 *(Point(p))
    (*Point)(p)         // p被转换成*Point
    <-chan int(c)       // 相当于 <-(chan int(c))
    (<-chan int)(c)     // c被转换成(<- chan int)
    func()(x)           // 函数签名 func() x
    (func())(x)         // x转换成func()
    (func() int)(x)     // x转换成func() int
    func() int(x)       // x转换成func() int，不混淆

一个常量x可以转换成类型T，如果x可以用类型T的值表示。特殊的例子，一个整型
常量和非常量x都可以显式的转换成为一个字符串类型，这个整型相当于是一个字符
的值。将一个常量转换成一个不是类型参数的类型将产生一个有类型的常量，将
常量转换成类型参数将产生一个实例化的类型实参类型的非常量值。 ::

    uint(iota)                  // 转换成uint
    float32(2.718281828)        // 转换成float32
    complex128(1)               // 转换成complex128类型的1.0+0.0i
    float32(0.49999999)         // 转换成float32类型的0.5
    float64(-1e-1000)           // 转换成float64类型的0.0，
    string('x')                 // 转换成string类型的"x"
    string(0x266c)              // 转换成string类型的"♬"
    myString("foo" + "bar")     // 转换成myString类型的"foobar"
    string([]byte{'a'})         // 转换成string类型的"a"
    (*int)(nil)                 // 转换成int型指针
    int(1.2)                    // 非法，浮点1.2不能用整数表示
    f := 3.14; a := int(f)      // 虽然常量转换是非法的，但是变量的转换是合法的
    string(65.0)                // 非法，浮点不是一个整数
    func f[P ~float32|~float64]() {
        P(1.1) // P(1.1) 转换成非常量值，其类型是float32或者float64
    }

如果满足以下条件之一，一个非常量值x可以转换成类型T：

1. x可以赋值给类型T
2. 忽略掉结构体标记，x的类型和T都不是类型参数，两个类型有相同的底层类型
3. 忽略掉结构体标记，x的类型和T都是非命名的指针类型，并且指向的类型不是类型参数但有相同的底层类型
4. x的类型和T都是整数或者浮点类型，即非常量值的整数和浮点可以相互强制转换
5. x的类型和T都是复数类型
6. x是一个整数、字节切片、字符切片，而T是一个字符串类型
7. x是一个字符串，而T是一个字节切片或者字符切片
8. x是一个切片，T是一个数组类型或者数组指针类型，并且切片和数组有相同的元素类型

如果x的类型V或者类型T是类型参数，如果满足以下条件之一，x也可以转换成T：

1. V和T都是类型参数，V中的每个类型的值都可以被转换成T中每个类型
2. 只有V是类型参数，V中的每个类型的值都可以被转换成类型T
3. 只有T是类型参数，x可以被转换成T定义的每个类型

Go语言的类型是与成员函数集合绑定的，你可以使用显式类型转换将一个类型转换成另一个类型，
比如将MyInt转换成int，相当于修改了类型的命名名称，并且将成员函数的集合也换掉了。但是
Go语言不允许改变一个复合结构类型的元素或成员的类型。

可比类型
========

比较操作比较两个操作数，两个操作数的类型必须能相互赋值，结果是一个无类型的布尔值。
比较操作分为两类，相等比较操作（==、!=）的两个操作数必须是可比类型（comparable type），
大小比较操作（<、<=、>、>=）的两个操作数必须是有序类型（ordered type）。

以下类型是有序的：

1. 整数类型
2. 浮点类型
3. 字符串类型

以下类型是可比的：

1. 布尔类型
2. 整数类型
3. 浮点类型
4. 复数类型
5. 字符串类型
6. 指针类型，指向同一个变量或者都是nil，指向两个不同的零大小变量的指针可能相等
7. 通道类型，调用相同make创建的两个通道相等，或者都是nil
8. 结构体类型，只要所有的成员都可比，按定义顺序依次比较非空成员值
9. 数组类型，只要数组元素是可比的，按照索引顺序依次比较
10. 非类型参数的接口类型是可比的，动态类型相同并且动态值相等，或者都是nil
11. 可比的实现了T的非接口类型X的值x与接口类型T的值t是可比的，相当于比较t的动态类型是否与X相同，动态值是否与x相等
12. 严格可比的两个类型参数是可比的

如果接口类型的值，其动态类型是不可比的，将会导致运行时异常。切片、映射、函数类型是不可
比的，但是它们的值都可以与nil进行比较。

不是接口类型也不包含接口类型的可比类型是严格可比的。具体的，以下类型严格可比（即实现了
comparable接口）：

1. 布尔类型
2. 整数类型
3. 浮点类型
4. 复数类型
5. 字符串类型
6. 指针类型
7. 通道类型
8. 如果所有成员严格可比，结构体类型严格可比
9. 如果元素类型严格可比，数组类型严格可比
10. 如果定义的类型都严格可比，类型参数严格可比
11. comparable类型约束自己对应的类型参数，严格可比

预声明的接口类型any表示空接口，是非接口类型的类型集合。预声明的接口类型comparable
表示严格可比较（strictly comparable）的类型集合。comparable不是一个基本接口类型，
comparable接口以及直接或间接内嵌了comparable接口的接口只能用作类型约束，不能作为
值或变量类型、元素或成员类型、或其他用途。

尽管基本接口类型（包括any接口）不是严格可比的，但是它们可比（即比较它们的动态类型
是否相同，动态值是否相等）。但是Go1.20版本规定，虽然不严格可比，基本接口类型仍然
满足comparable接口，即基本接口类型虽然没有实现comparable接口，但是满足comparable
约束（参见 `类型约束`_），以实现泛型传参的灵活性。当然，如果接口变量的动态类不可比，
对应的比较操作会出现运行时异常。 ::

    类型            约束                       是否实现接口              是否满足约束
    int            interface{~int}            int实现了接口             满足
    string         comparable                 string实现了接口          满足
    []byte         comparable                 切片没有实现接口           不满足
    any            interface{comparable; int} any没有实现interface{int} 不满足
    any            comparable                 any没有实现comparable     但是满足comparable
    struct {f any} comparable                 any没有实现comparable     但是满足comparable，因而结构体满足约束
    any            interface{comparable; m()} any没有实现interface{m()} 不满足
    interface{m()} interface{comparable; m()} 接口没有实现comparable     但是满足comparable，因而接口满足约束

静态类型
========

变量的静态类型（static type）是变量声明时给定的类型，接口类型的变量不仅有静态
类型，还可以有不同的动态类型（dynamic type），这个动态类型是一个非接口类型，
它是在运行时接口变量持有的具体值的类型。如果接口变量的值为nil，表示这个变量此时
没有动态类型。接口变量的动态类型可以在运行时随时改变，但是接口变量中存储的值始终
是一个可以赋值给接口变量静态类型的值。 ::

    var x interface{} // 变量x的静态类型是interface{}，当前的值是nil
    var v *T          // 变量v的静态类型是*T，当前的值为nil
    x = 42            // 接口变量x的动态类型变成int，其值是42
    x = v             // 接口变量x的动态类型变成*T，其值是(*T)(nil)

类型断言表达式x.(T)可以用来判断接口变量x的动态类型与类型T的关系，利用类型断言可以
访问接口变量的动态类型或者可以将接口变量转换为非接口变量：

1. 如果T是静态类型，x的值不为nil并且其动态类型与类型T相同
2. 如果T是接口类型，x的值不为nil并且其动态类型实现了T接口

类型switch可以用来比较类型，它使用类型断言语法的形式来判断一个值的类型::

    switch [ SimpleStmt ";" ] [ identifier ":=" ] x.(type) {
    // cases
    }

类型switch的switch表达式之前可以有一个简单语句，这条语句在switch表达式之前求值。
fallthrough语句不允许出现在类型switch中。像类型断言一样，x必须是一个非类型参数
的接口类型的值，而且case中的每个非接口类型T都必须实现了该接口。类型switch将表达
式x的动态类型与case中的实际类型T进行匹配，case中列出的类型必须都是不同的，除非
有类型参数或者泛型类用在case表达式中，此时如果实例化后出现两个相同的case，会选择
第一个出现的case::

    func f[P any](x any) int {
        switch x.(type) {
        case P:
            return 0
        case string:
            return 1
        case []P:
            return 2
        case []byte:
            return 3
        default:
            return 4
        }
    }
    var v1 = f[string]("foo")   // 匹配case P，v1值为0
    var v2 = f[byte]([]byte{})  // 匹配case []P，v2值为2

类型switch语句可以包含一个短变量声明，这个变量的作用域在case或default语句块内。如果
case包含唯一一个类型，那么该变量的类型就是这个类型，否则为x的类型。case表达式除了使用
类型，也可以使用nil，表示接口变量x是否为nil。例如假设x类型为interface{}::

    switch i := x.(type) {
    case nil:
        printString("x is nil")                // i的类型是x的类型interface{}
    case int:
        printInt(i)                            // i的类型是int
    case float64:
        printFloat64(i)                        // i的类型是float64
    case func(int) float64:
        printFunction(i)                       // i的类型是函数func(int) float64
    case bool, string:
        printString("type is bool or string")  // i的类型是x的类型interface{}
    default:
        printString("don't know the type")     // i的类型是x的类型interface{}
    }

接口类型
========

接口类型定义了一个非接口类型的类型集合。接口类型由接口元素列表定义，接口元素可以
是成员函数元素和类型元素。类型元素可以是单个类型（T）、单个底层类型（~T）、或者
多个类型的联合（ ``t1|t2|…|tn`` ）。如果单个类型是另外一个接口类型，相当于当前
接口内嵌了另一个接口，将获得内嵌接口的所有元素。接口I不能内嵌接口I，也不能内嵌一
个直接或间接内嵌了I的接口（不能有嵌套循环）。当前接口中的函数名称不能是空标识符，
而且必须唯一不能与其他函数名相同，但是可以与内嵌接口中的函数名相同，但它们必须拥
有相同的函数签名。

类型元素T可以是：

1. 非接口类型：比如int string MyInt
2. 接口类型：包括基本接口、泛型接口 
3. 不能是类型参数

类型元素~T中的T是：

1. 非接口类型中底层类型是自己的类型：比如int string
2. 不能是接口类型
3. 不能是类型参数

类型联合（至少两个元素）中的类型元素：

1. 不能是comparable接口
2. 不能是包含成员函数元素的接口，即必须是不包含成员函数元素的泛型接口或any
3. 不能是内嵌了以上两种接口的接口
4. 一个类型联合中非接口类型元素定义的类型集合不能有交集

接口类型分为基本接口（basic interface）和泛型接口（generic interface）两类：

- 基本接口类型：只包含成员函数元素（可能为空），可以内嵌其他基本接口
- 泛型接口类型：还可以包含泛型接口以及非接口类型的类型元素，只能作为类型约束使用

基本接口可以正常使用，比如用作类型约束，作为值或变量的类型，元素或成员的类型。但是
泛型接口只能作为类型约束使用，不能用作值或变量的类型、元素或成员的类型、或其他用途。

一个接口定义的类型集合如下（根据定义，该类型集合不可能包含接口类型）：

1. 空接口定义了所有非接口类型
2. 非空接口定义的类型是所有接口元素定义的类型的交集
3. 一个成员函数元素定义的类型是那些实现了这个成员函数的非接口类型
4. 一个非接口类型元素T定义的类型是这一单个类型T
5. 类型元素~T定义的类型是所有底层类型是T的类型
6. 类型联合 ``t1|t2|…|tn`` 定义的类型是所有这些类型元素定义的类型的并集

特别的，空接口interface{}定义的类型是所有非接口类型，空接口可以用预声明的类型
any表示。另外，空集合接口也可以作为类型约束用来声明类型参数，空集合接口即那些
定义的类型集合为空的接口，例如 interface {int; string}。但是有空集合接口类型
参数的泛型函数不能被实例化，任何实例化的尝试都会报错。

一个类型T如果满足以下条件之一，表示T实现了接口I：

1. T不是接口类型，T是I定义的类型集合中的一个类型
2. T是接口类型，T的类型集合是I的类型集合的子集，即实现T的类型一定实现了I

类型T定义的成员函数集合是那些使用T为接收参数的成员函数集合，类型T的指针类型*T
定义的成员函数集合是以T或*T为接收参数的成员函数集合。因此要注意的是，如果一个
类型定义的成员函数全部都是以*T为接收参数，那么类型T肯定没有实现接口I，如果实现
了接口I的所有成员函数，也只是类型*T实现了接口I。 ::

    type MyInt int
    type Float interface {
        ~float32 | ~float64
    }
    type MyType[P comparable] interface {
        P               // 非法，类型元素不能是类型参数
        int | ~P        // 非法，类型元素不能是类型参数
    }
    interface {
        ~[]byte         // 合法，[]byte的底层类型是自己
        ~MyInt          // 非法，MyInt的底层类型不是自己，而是int
        ~error          // 非法，error是一个接口
    }
    interface {
        comparable       // 合法，类型元素可以是接口
        Float            // 合法，类型元素可以是接口
        MyInt            // 合法，类型元素可以是非接口类型
        int              // 合法，类型元素可以是非接口类型
        String() string  // 合法，接口可以包含成员函数元素
        ~int | MyInt     // 非法，类型联合中的非接口类型定义的类型集合有交集，~int包含了MyInt
        float32 | Float  // 合法，有交集，但是Float是接口类型
        int | any        // 合法，有交集，但是any是接口类型
        int | comparable // 非法，类型联合中不能包含comparable
    }

类型约束
========

类型约束其实就是一个接口类型，包括基本接口和泛型接口都可以用作类型约束，只不过基本
接口还可以用作变量的类型等其他用途，但泛型接口只能作为类型约束使用。类型约束定义了
对应类型参数允许的类型实参集合，并控制类型参数对应值支持的操作。

有一个预声明的接口类型comparable，定义了一个严格可比较的非接口类型的类型集合。尽管
非类型参数的接口类型是可比的，但它们不是严格可比，因此没有实现comparable接口。然而
Go1.20版本规定，这些接口仍然满足comparable约束。comparable接口以及直接或间接包含了
comparable接口的接口都只能作为类型约束使用，不能用作其他用途。

具体的，一个类型实参T满足一个类型约束的条件如下：

1. 约束是一个基本接口I，T实现了I，则T的变量可以赋值给I的变量，并且T满足约束I
2. 约束是一个泛型接口C，T实现了C，则T满足约束C，T可以赋给C对应的类型参数
3. 一个列外是，如果C可以写成形式interface{comparable; E}，其中E是一个基本接口，
   并且T实现了接口E，并且T可比较，即使T不是严格可比较的（没有实现comparable接口），
   T仍然满足C

类型约束只能用来声明类型参数，或定义新的类型约束（用于类型声明、接口类型元素）：

1. 类型参数列表中的类型约束如果只包含单个类型元素或类型联合，在不引起歧义的情况下可以省略interface{}
2. 在类型参数列表之外，特别是~T形式的类型元素以及类型联合的使用是非法的
3. 因为类型约束仅仅是一个接口类型，可以用作类型声明的原类型，或者接口的类型元素
4. 但是用类型约束声明的类型参数，不能用作类型声明的原类型，也不能用作接口的类型元素

例如::

    type T[P *C] …                   // 可能引起歧义，因为P*C可以解析为数组长度
    type T[P (C)] …                  // 可能引起歧义，因为P(C)可以解析为数组长度
    type T[P *C|Q] …                 // 可能引起歧义，因为(P*C)|Q可以解析为数组长度
    type T[P interface{*C}] …        // 解决方法之一是，不省略interface{}
    type T[P *C,] …                  // 解决方法之二是，在尾部加一个逗号
    [T []P]                          // 相当于 [T interface{[]P}]
    [T ~int]                         // 相当于 [T interface{~int}]
    [T int|string]                   // 相当于 [T interface{int|string}]
    type Constraint ~int             // 非法，没有interface{}的单个类型元素或类型联合只能出现在类型参数列表中
    var x Float                      // 非法，Float不是一个基本接口，不能用作变量的类型
    var x interface{} = Float(nil)   // 非法，泛型接口不能用作值的类型
    type Floatish struct { f Float } // 非法，泛型接口不能用作成员的类型

类型参数
========

使用类型约束，可以为泛型类和泛型函数声明类型参数列表。类型参数列表由多个类型参数组成，
每个类型参数有一个命名的标识符名称，每个类型参数允许的类型集合由对应的类型约束限定。
类型参数跟函数参数类似，不同的是类型参数表示的是一个类型，而函数参数表示的是一个值。
类型参数相当于是满足对应类型约束的一个未知类型的占位，这个未知类型可以是一个非接口
类型也可以是一个接口类型（只要这个接口类型定义的类型集合是类型约束定义的类型集合的
子集，另外基本接口类型也满足comparable约束）。

类型参数列表如果存在不能为空，泛型类中的类型约束不能直接或间接引用泛型类自身。只有将每个
类型参数都替换成类型实参，泛型类才能变成一个具体的类型，泛型函数才能变成一个具体的函数，
这个过程称为实例化。泛型类只有实例化成具体的类型才能正常使用。泛型函数也必须在实例化之后
才能被调用或者当作一个函数值使用。有类型参数的函数声明必须有函数体。没有类型参数的函数声
明可以没有函数体，表示这仅仅是一个签名，其函数体的具体实现在其他地方。

成员函数的接收参数也可以指定类型参数，但它其实是泛型类的实例化形式。相当于给泛型类定义
成员函数::

    func (l *List[T]) Len() int { … }
    func (p Pair[A, B]) Swap() Pair[B, A] { … }
    func (p Pair[First, _]) First() First { … }

实例化过程分为两步，第一步进行类型参数替换（类型实参和类型参数之间必须可赋值≡A），这个替
换发生在整个函数或类的声明中，包括类型参数列表自身和其中的所有类型；第二步检查类型约束是
否满足（类型实参对应的类型必须满足约束≡C）。泛型函数的自动类型推导，也是通过赋值性≡A类型
等式和满足约束≡C类型等式构成的方程组来求解对应类型参数的。详情见语言规范的类型推导部分。

对于泛型类，所有的类型实参都必须提供。对于泛型函数，类型实参可以显式提供，也可以部分或者
全部通过函数调用和返回值、或者函数值的赋值涉及的类型进行自动类型推导，这种情况可以省略一
部分或者全部类型实参，如果部分省略只能省略参数后边部分，至少第一个类型实参必须提供。
